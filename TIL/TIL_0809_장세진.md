# Socket

##### 1. 정의

- 연결된 네트워크의 양 끝단을 추상화 시킨 개념
- 네트워크 상에서 서버와 클라이언트 두개의 프로그램이 특정 포트를 통해 양방향 통신이 가능하도록 만들어주는 소프트웨어 장치



##### 2. socket 생성

- `socket.socket()`
  - 이 함수는 두 가지 인자를 받음 => 패밀리, 타입

##### 3. 바인드와 리스닝

- `sock.bind()`
  - 프로그램 인터페이스인 소켓과 네트워크 자원인 포트를 연결하는 행위 
- `sock.listen()`



##### 4. 정보 주고 받기

- `sock.recv()`
  - 읽어들일 데이터가 없다면, 데이터를 보내줄때까지 대기한다. 
- `sock.sendall()`



**python 예시 코드**

```python
import socket
import pickle

# 서버
def run_server(port,do_work_server,s_count=1):
    # 1. 초기화
    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    
    # 2. bind
    server.bind(('',port))
    
    # 3. listen
    server.listen(1)
    
    # 4. accept
    while s_count > 0:
        print('클라이언트 접속을 기다립니당나귀')
        client,addr = server.accept()
        
        do_work_server(client, addr)
        client.close()
        s_count-=1
        
    server.close()

# 공통
# 아래의 두 함수는 데이터를 주고 받기 위한 함수
def my_recv(B_SIZE,client):
    data = client.recv(B_SIZE)
    if not data:
        return data
    cmd = pickle.loads(data)
    return cmd

def my_send(cmd, client):
    data = pickle.dumps(cmd) # 직렬화
    client.sendall(data)
    
    return 0

```

```python
# 처음 서버가 실행되고 클라이언트와 연결을 기다리며 클라이언트에서 보낸 데이터를 받아 연산하고 다시 돌려줌
import mynetlib

def do_work_server(client, addr):
    print('client :', addr)
    
    cmd_r = mynetlib.my_recv(1024, client)
    print(cmd_r[0], cmd_r[1])
    a = cmd_r[0]
    b = cmd_r[1]
    cmd_s = [a+b,a-b,a*b]
    mynetlib.my_send(cmd_s,client)
    
    
mynetlib.run_server(2023, do_work_server,1)
출처: https://nevertrustbrutus.tistory.com/476 [FU11M00N:티스토리]
```

